Использование FTS в PostgreSQL
===
**1. Тип tsvector**</br>
Задание 1</br>
После выполнения запроса</br>
```sql
SELECT to_tsvector('Съешь ещё этих мягких французских булок, да выпей чаю');
```
был получен результат</br>
```sql
                    to_tsvector
'булок':6 'вып':8 'ещ':2 'мягк':4 'съеш':1 'французск':5 'ча':9 'эт':3
```
В векторе отсутствует слово `да`, т.к. это слово распознаётся словарём как стоп-слово.</br></br>
**2. Тип tsquery**</br>
Задание 2</br>
`@@` - оператор типа boolean, проверяющий соответствие tsvector и tsquery.</br>
Из трёх запросов</br>
```sql
--№1
SELECT to_tsvector('The quick brown fox jumped over the lazy dog')  
    @@ to_tsquery('fox');
--№2
SELECT to_tsvector('The quick brown fox jumped over the lazy dog')  
    @@ to_tsquery('foxes');
--№3 
SELECT to_tsvector('The quick brown fox jumped over the lazy dog')  
    @@ to_tsquery('foxhound');
```
первый и второй возвращают **true**, а третий **false**. Это связано с тем, что `fox` и `foxhound`
являются разными по смыслу словами (fox - лиса, foxhound - порода собаки). Лексема в словаре для слова fox - fox, для foxhound - foxhound.
</br>
В результате запроса
```sql
SELECT to_tsvector('Russian', 'Съешь ещё этих мягких французских булок, да выпей чаю.')
    @@ to_tsquery('Russian','булка');
```
не находится слово `булка`, т.к. лексемы для слов `булка` и `булок` отличаются. Для слова булка - булк, а для булок - булок.
</br>
В результате выполнения двух запросов</br>
```sql
--№1
SELECT to_tsvector('Russian', 'Съешь ещё этих мягких французских пирожков, да выпей чаю.')
    @@ to_tsquery('Russian','пирожки');
--№2
SELECT to_tsvector('Russian', 'Съешь ещё этих мягких французских пирожков, да выпей чаю.')
    @@ to_tsquery('Russian','пирожок');
```
первый выводит true, второй false. Лексема слова `пирожков` - пирожк. Только в первом запросе лексема слова в tsquery будет 
соответсвовать лексеме слова в tsvector (пирожки - пирожк, пирожок - пирожок).
</br></br>
**3. Операторы**</br>
Задание 3</br>
Запросы на русском:</br>
```sql
--И
SELECT to_tsvector('У коровы нет других забот - ест траву и молоко даёт.')  
    @@ to_tsquery('корова & трава');
        
--ИЛИ
SELECT to_tsvector('У коровы нет других забот - ест траву и молоко даёт.')  
    @@ to_tsquery('корова | лошадь');
    
--Отрицание
SELECT to_tsvector('У коровы нет других забот - ест траву и молоко даёт.')  
    @@ to_tsquery('!бык');
    
--Группировка
SELECT to_tsvector('У коровы нет других забот - ест траву и молоко даёт.')  
    @@ to_tsquery('корова & (трава | цветы) & !бык');
```
Если аргумент не определен, то используется конфигурация по умолчанию, записанная в параметре `default_text_search_config` в файле `postgresql.conf`. Встроенное значение по умолчанию для данного параметра — `pg_catalog.simple`, но initdb при инициализации записывает в файл конфигурации сервера значение, соответствующее выбранной локали lc_ctype, если удастся найти такую конфигурацию текстового поиска. 

    # default configuration for text search
    default_text_search_config = 'pg_catalog.russian'

В настоящее время в PostgreSQL есть только один встроенный анализатор текста, который может быть полезен для широкого круга приложений. Этот встроенный анализатор называется `pg_catalog.default`. Он распознаёт 23 типа фрагментов.
</br></br>
**4. Поиск фраз**</br>
Задание 4</br>
Запрос
```sql
SELECT to_tsvector('Russian', 'Съешь ещё этих мягких французских булок, да выпей чаю.')
    @@ to_tsquery('Russian','мягких<2>булок');
```
Оператор `<->` показывает, предшествует ли одно слово другому.</br>
Число 2 в операторе `<->` показывает расстояние между словами. В запросе мы хотим узнать, стоит ли слово `мягких` от слова `булок` в 2 шагах. В данном случаем результат запроса будет true.</br>
Если необходимо найти фразу `съешь ещё`, то можно использовать следующий запрос
```sql
SELECT to_tsvector('Russian', 'Съешь ещё этих мягких французских булок, да выпей чаю.')
    @@ to_tsquery('Russian','съешь<1>ещё');
```
Функция `phraseto_tsquery` полезна при поиске точных последовательностей лексем.
Результатом запроса 
```sql
SELECT phraseto_tsquery('Съешь ещё этих мягких французских булок, да выпей чаю.');
```
будет
```sql
'съеш' <-> 'ещ' <-> 'эт' <-> 'мягк' <-> 'французск' <-> 'булок' <2> 'вып' <-> 'ча'
```
**5. Утилиты**</br>
**ts_debug**</br>
С помощью функции `ts_debug` можно легко протестировать конфигурацию текстового поиска.</br>
`ts_debug` выводит информацию обо всех фрагментах данного документа, которые были выданы анализатором и обработаны настроенными словарями.</br>
`ts_debug` возвращает по одной строке для каждого фрагмента, найденного в тексте анализатором. Эта строка содержит следующие столбцы:</br>
* синоним text — краткое имя типа фрагмента;
* описание text — описание типа фрагмента;
* фрагмент text — текст фрагмента;
* словари regdictionary[] — словари, назначенные в конфигурации для фрагментов такого типа;
* словарь regdictionary — словарь, распознавший этот фрагмент, или NULL, если подходящего словаря не нашлось;
* лексемы text[] — лексемы, выданные словарём, распознавшим фрагмент, или NULL, если подходящий словарь не нашёлся; может быть также пустым массивом ({}), если фрагмент распознан как стоп-слово.</br>

Например, выполнив запрос
```sql
SELECT ts_debug('Russian', 'Съешь ещё этих мягких французских булок, да выпей чаю.');
```
можно увидеть следующий результат
```sql
(word,"Word, all letters",Съешь,{russian_stem},russian_stem,{съеш})
(blank,"Space symbols"," ",{},,)
(word,"Word, all letters",ещё,{russian_stem},russian_stem,{ещ})
(blank,"Space symbols"," ",{},,)
(word,"Word, all letters",этих,{russian_stem},russian_stem,{эт})
(blank,"Space symbols"," ",{},,)
(word,"Word, all letters",мягких,{russian_stem},russian_stem,{мягк})
(blank,"Space symbols"," ",{},,)
(word,"Word, all letters",французских,{russian_stem},russian_stem,{французск})
(blank,"Space symbols"," ",{},,)
(word,"Word, all letters",булок,{russian_stem},russian_stem,{булок})
(blank,"Space symbols",", ",{},,)
(word,"Word, all letters",да,{russian_stem},russian_stem,{})
(blank,"Space symbols"," ",{},,)
(word,"Word, all letters",выпей,{russian_stem},russian_stem,{вып})
(blank,"Space symbols"," ",{},,)
(word,"Word, all letters",чаю,{russian_stem},russian_stem,{ча})
(blank,"Space symbols",.,{},,)
```
**ts_headline**  
Функция `ts_headline` предоставляет возможность показать фрагменты документа с отмеченными искомыми словами. `ts_headline` принимает документ вместе с запросом и возвращает выдержку из документа, в которой выделяются слова из запроса.  
Например, результатом запроса
```sql
SELECT ts_headline('Russian', 'Гарри вскочил с постели. Счастье распирало его изнутри, словно он проглотил воздушный шар. Гарри подошел к окну и распахнул его. Сова влетела в комнату и уронила газету прямо на Хагрида, но тот не проснулся. Затем сова спикировала на пол и набросилась на куртку Хагрида.', 
to_tsquery('сова & газета & счастье'), 'StartSel = <, StopSel = >');
```
будет
```sql
<Счастье> распирало его изнутри, словно он проглотил воздушный шар. Гарри подошел к окну и распахнул его. <Сова> влетела в комнату и уронила <газету>
```
где символами `<>` будут выделены искомые слова.
